<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>éŒ²éŸ³ãƒ¡ãƒ¢ Pro + å›³å½¢è£œæ­£</title>
    <style>
        :root {
            --primary-color: #007aff; --danger-color: #ff3b30; --success-color: #34c759; --bg-header: #f8f8f8;
        }
        body {
            margin: 0; display: flex; flex-direction: column; height: 100vh;
            font-family: -apple-system, sans-serif; background: #ccc; overflow: hidden; position: fixed; width: 100%;
        }
        header {
            background: var(--bg-header); padding: 12px; display: flex; flex-wrap: wrap;
            gap: 10px; align-items: center; z-index: 2000; box-shadow: 0 2px 10px rgba(0,0,0,0.15);
        }
        .mode-selector { display: flex; background: #e0e0e0; border-radius: 12px; padding: 3px; }
        .mode-btn { padding: 10px 20px; border: none; border-radius: 9px; cursor: pointer; font-weight: bold; font-size: 16px; }
        .active { background: white; color: var(--primary-color); }

        /* ã‚«ãƒ©ãƒ¼é¸æŠ */
        .color-picker { display: flex; gap: 8px; margin: 0 10px; }
        .color-dot {
            width: 35px; height: 35px; border-radius: 50%; border: 2px solid transparent; cursor: pointer;
        }
        .color-dot.selected { border-color: #555; transform: scale(1.1); }

        button { padding: 10px 16px; border-radius: 10px; border: none; font-size: 15px; font-weight: bold; }
        #recordBtn { background: var(--primary-color); color: white; }
        #stopBtn { background: var(--danger-color); color: white; }
        #saveBtn { background: var(--success-color); color: white; }
        #clearBtn { background: #8e8e93; color: white; margin-left: auto; }

        #scroll-container { flex-grow: 1; overflow-y: scroll; background: #fafafa; -webkit-overflow-scrolling: touch; }
        canvas { display: block; background: #fff; touch-action: none; }
        .audio-wrapper { display: flex; align-items: center; background: #fff; padding: 2px 10px; border-radius: 20px; border: 1px solid #ddd; }
        audio { height: 40px; width: 200px; }
    </style>
</head>
<body>
    <header id="app-header">
        <div class="mode-selector">
            <button id="drawModeBtn" class="mode-btn active">ğŸ–Š æã</button>
            <button id="scrollModeBtn" class="mode-btn">âœ‹ ç§»å‹•</button>
        </div>

        <div class="color-picker" id="colorPicker">
            <div class="color-dot selected" style="background: #000;" data-color="#000000"></div>
            <div class="color-dot" style="background: #ff3b30;" data-color="#ff3b30"></div>
            <div class="color-dot" style="background: #007aff;" data-color="#007aff"></div>
            <div class="color-dot" style="background: #34c759;" data-color="#34c759"></div>
        </div>
        
        <button id="recordBtn">éŒ²éŸ³é–‹å§‹</button>
        <button id="stopBtn" disabled>åœæ­¢</button>
        <div id="audio-container"></div>
        <button id="saveBtn">ãƒ¡ãƒ¢ä¿å­˜</button>
        <button id="clearBtn">æ¶ˆå»</button>
        <div id="status" style="font-size:12px; font-weight:bold;">åœæ­¢ä¸­</div>
    </header>

    <div id="scroll-container">
        <canvas id="memoCanvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('memoCanvas');
        const container = document.getElementById('scroll-container');
        const ctx = canvas.getContext('2d', { desynchronized: true });
        const audioContainer = document.getElementById('audio-container');
        const status = document.getElementById('status');

        let isDrawing = false;
        let editMode = 'draw';
        let currentColor = '#000000';
        let currentPath = []; // å›³å½¢åˆ¤å®šç”¨
        let holdTimer; // é•·æŠ¼ã—åˆ¤å®šç”¨
        const INITIAL_HEIGHT = 4000;

        function initCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = INITIAL_HEIGHT;
            ctx.fillStyle = "#ffffff"; ctx.fillRect(0, 0, canvas.width, canvas.height);
            setPenStyle(); loadFromLocalStorage();
        }

        function setPenStyle() {
            ctx.lineWidth = 2.5; ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.strokeStyle = currentColor;
        }

        // --- ã‚«ãƒ©ãƒ¼é¸æŠ ---
        document.querySelectorAll('.color-dot').forEach(dot => {
            dot.onclick = () => {
                document.querySelector('.color-dot.selected').classList.remove('selected');
                dot.classList.add('selected');
                currentColor = dot.dataset.color;
                setPenStyle();
            };
        });

        // ãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿
        document.getElementById('drawModeBtn').onclick = (e) => {
            editMode = 'draw'; e.target.classList.add('active');
            document.getElementById('scrollModeBtn').classList.remove('active');
        };
        document.getElementById('scrollModeBtn').onclick = (e) => {
            editMode = 'scroll'; e.target.classList.add('active');
            document.getElementById('drawModeBtn').classList.remove('active');
        };

        // --- å›³å½¢è£œæ­£ãƒ­ã‚¸ãƒƒã‚¯ ---
        function recognizeShape(path) {
            if (path.length < 20) return null;
            const xs = path.map(p => p.x); const ys = path.map(p => p.y);
            const minX = Math.min(...xs); const maxX = Math.max(...xs);
            const minY = Math.min(...ys); const maxY = Math.max(...ys);
            const width = maxX - minX; const height = maxY - minY;
            const centerX = (minX + maxX) / 2; const centerY = (minY + maxY) / 2;

            // å§‹ç‚¹ã¨çµ‚ç‚¹ã®è·é›¢
            const dist = Math.hypot(path[0].x - path[path.length-1].x, path[0].y - path[path.length-1].y);
            if (dist > 100) return null; // é–‰ã˜ã¦ã„ãªã„å›³å½¢ã¯ç„¡è¦–

            // å††åˆ¤å®š (ä¸­å¿ƒã‹ã‚‰ã®è·é›¢ã®åˆ†æ•£ã§ç°¡æ˜“åˆ¤å®š)
            const radius = (width + height) / 4;
            let isCircle = true;
            for(let i=0; i<path.length; i+=5) {
                const d = Math.hypot(path[i].x - centerX, path[i].y - centerY);
                if (Math.abs(d - radius) > radius * 0.3) { isCircle = false; break; }
            }
            if (isCircle) return { type: 'circle', x: centerX, y: centerY, r: radius };
            
            // ãã‚Œä»¥å¤–ã¯å››è§’
            return { type: 'rect', x: minX, y: minY, w: width, h: height };
        }

        function applyShape(shape) {
            // ç›´å‰ã®æ‰‹æ›¸ãç·šã‚’æ¶ˆã™ãŸã‚ã«å†æç”»ï¼ˆç°¡æ˜“ç‰ˆï¼šç›´å‰ã®ãƒ‘ã‚¹éƒ¨åˆ†ã‚’ç™½å¡—ã‚Šã—ã¦ä¸Šæ›¸ãï¼‰
            // å®Ÿéš›ã¯ç”»é¢å…¨ä½“ã‚’æˆ»ã™ã®ãŒç†æƒ³ã§ã™ãŒã€ã“ã“ã§ã¯ä¸Šã‹ã‚‰ç¶ºéº—ãªå›³å½¢ã‚’é‡ã­ã¾ã™
            ctx.strokeStyle = currentColor; ctx.lineWidth = 3;
            if (shape.type === 'circle') {
                ctx.beginPath(); ctx.arc(shape.x, shape.y, shape.r, 0, Math.PI * 2); ctx.stroke();
            } else {
                ctx.strokeRect(shape.x, shape.y, shape.w, shape.h);
            }
        }

        // æç”»ã‚¤ãƒ™ãƒ³ãƒˆ
        canvas.addEventListener('touchstart', (e) => {
            if (editMode !== 'draw') return;
            isDrawing = true; currentPath = [];
            const t = e.touches[0]; const rect = canvas.getBoundingClientRect();
            const p = { x: t.clientX - rect.left, y: t.clientY - rect.top };
            currentPath.push(p);
            ctx.beginPath(); ctx.moveTo(p.x, p.y);
            
            // é•·æŠ¼ã—ã‚¿ã‚¤ãƒãƒ¼é–‹å§‹
            clearTimeout(holdTimer);
            holdTimer = setTimeout(() => {
                if (isDrawing && currentPath.length > 20) {
                    const shape = recognizeShape(currentPath);
                    if (shape) {
                        // æ‰‹æ›¸ãã‚’æ¶ˆã™ã®ã¯é›£ã—ã„ã®ã§ã€ä¸€åº¦æç”»ã‚’æ­¢ã‚ã¦å›³å½¢ã‚’æã
                        isDrawing = false;
                        applyShape(shape);
                        saveToLocalStorage();
                    }
                }
            }, 700);
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            if (!isDrawing || editMode !== 'draw') return;
            e.preventDefault();
            const t = e.touches[0]; const rect = canvas.getBoundingClientRect();
            const p = { x: t.clientX - rect.left, y: t.clientY - rect.top };
            currentPath.push(p);
            ctx.lineTo(p.x, p.y); ctx.stroke();
            if (p.y > canvas.height - 800) { /* å»¶é•·å‡¦ç†çœç•¥...å‰å›ã¨åŒã˜ */ }
        }, { passive: false });

        canvas.addEventListener('touchend', () => {
            clearTimeout(holdTimer);
            if (isDrawing) { isDrawing = false; saveToLocalStorage(); }
        });

        // --- éŒ²éŸ³ãƒ»ä¿å­˜ (å‰å›ã¨åŒã˜) ---
        const recordBtn = document.getElementById('recordBtn');
        const stopBtn = document.getElementById('stopBtn');
        recordBtn.onclick = async () => {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];
                mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) audioChunks.push(e.data); };
                mediaRecorder.onstop = () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/mp4' });
                    const audioUrl = URL.createObjectURL(audioBlob);
                    audioContainer.innerHTML = `<div class="audio-wrapper"><audio src="${audioUrl}" controls playsinline></audio></div>`;
                    const link = document.createElement('a'); link.href = audioUrl; link.download = `voice_${Date.now()}.mp4`; link.click();
                    status.innerText = "ä¿å­˜å®Œäº†";
                };
                mediaRecorder.start(); recordBtn.disabled = true; stopBtn.disabled = false; status.innerText = "éŒ²éŸ³ä¸­...";
            } catch (err) { alert(err.message); }
        };
        stopBtn.onclick = () => { mediaRecorder.stop(); recordBtn.disabled = false; stopBtn.disabled = true; };
        document.getElementById('saveBtn').onclick = () => {
            const link = document.createElement('a'); link.href = canvas.toDataURL("image/jpeg", 0.9);
            link.download = `memo_${Date.now()}.jpg`; link.click();
        };

        function saveToLocalStorage() { localStorage.setItem('myMemoData', canvas.toDataURL("image/jpeg", 0.5)); }
        function loadFromLocalStorage() {
            const savedData = localStorage.getItem('myMemoData');
            if (savedData) { const img = new Image(); img.src = savedData; img.onload = () => ctx.drawImage(img, 0, 0); }
        }
        document.getElementById('clearBtn').onclick = () => { if(confirm("æ¶ˆå»ï¼Ÿ")) { 
            ctx.fillStyle = "#ffffff"; ctx.fillRect(0, 0, canvas.width, canvas.height); saveToLocalStorage(); } 
        };
        window.onload = initCanvas;
    </script>
</body>
</html>
